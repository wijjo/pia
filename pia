#!/usr/bin/env python3

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License Version 2 as published by
## the Free Software Foundation.
#
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License at (http://www.gnu.org/licenses/) for
## more details.


"""
Private Internet Access front-end for openvpn.

Based on original pia.sh Bash script from https://github.com/d4rkcat/pia.

It is only tested on Linux, but is intended to be portable to other systems.

Porting to Windows will likely require some work, but assumptions about the
target system were avoided or at least made clear.
"""

import sys
import os
if sys.version_info.major < 3:
    sys.stderr.write('ERROR: This script requires Python version 3.{}'.format(os.linesep))
    sys.exit(1)

import collections
import re

from lib import command
from lib import configuration
from lib import credentials
from lib import firewall
from lib import openvpn
from lib import pia
from lib import tools


REQUIRED_PACKAGES = [
    tools.Package('openvpn', executable='openvpn'),
]

COMMAND_DESCRIPTION = 'OpenVPN front-end'

ProviderPaths = collections.namedtuple('Server', [
    'config_dir', 'state_dir', 'download_dir', 'port_path'
])


class ProviderSubCommand(command.SubCommand):
    """Base class for VPN provider-related sub-commands."""

    vpn_device_regex = re.compile(r'TUN/TAP device (\w+) opened')
    iproute_show_regex = re.compile(r'^default via ([0-9.]+) dev (\w+) ')
    vpn_config_remote_regex = re.compile(r'^\s*remote ([^\s]+) (\d+)\s*$')
    vpn_config_protocol_regex = re.compile(r'^\s*proto (\w+)\s*$')

    def __init__(self, argument_parser, sub_command_argument_parsers):
        #TODO: Support other non-PIA providers.
        provider_cls = pia.PIAProvider
        self.base_dir = tools.create_directory('~', '.{}'.format(provider_cls.short_name))
        self.config_dir = tools.create_directory(self.base_dir, 'configuration')
        self.state_dir = tools.create_directory(self.base_dir, 'state')
        self.download_dir = tools.create_directory(self.base_dir, 'downloads')
        self.config_path = os.path.join(self.config_dir, '{}.conf'.format(provider_cls.short_name))
        self.cred_path = os.path.join(self.config_dir, '{}.cred'.format(provider_cls.short_name))
        self.port_path = os.path.join(self.state_dir, '{}.port'.format(provider_cls.short_name))
        self.state_path = os.path.join(self.state_dir, '{}.state.json'.format(provider_cls.short_name))
        self.pid_path = os.path.join(self.state_dir, '{}.pid'.format(provider_cls.short_name))
        self.log_path = os.path.join(self.state_dir, '{}.log'.format(provider_cls.short_name))
        self.provider = provider_cls(ProviderPaths(
            self.config_dir,
            self.state_dir,
            self.download_dir,
            self.port_path,
        ))
        # Data loaded (lazily) from the user configuration file.
        self.saved_state = tools.PersistentJSONData(self.state_path, 'state')
        super().__init__(argument_parser, sub_command_argument_parsers)

    def cleanup(self):
        """Cleanup, e.g. flush persistent data."""
        self.saved_state.save()

    @property
    def openvpn_servers(self):
        """Provide and manage cached OpenVPN server list."""
        if not hasattr(self, '_openvpn_servers'):
            self._openvpn_servers = self.provider.get_servers()
        return self._openvpn_servers

    @property
    def config(self):
        """On-demand access to user configuration data."""
        if not hasattr('_config'):
            self._config = configuration.Data(self.config_path, self.openvpn_servers)
            self._config.load()
        return self._config

    @property
    def credentials(self):
        """On-demand access to user credentials."""
        if not hasattr('_credentials'):
            self._credentials = credentials.Credentials(self.cred_path)
        return self._credentials

    def select_servers(self, server_config):
        """Select a server based on options, selection method, and persistent state."""
        # Create the server sequence based on the selected discipline.
        discipline = (server_config.discipline or 'first').lower()
        if discipline == 'first':
            servers = server_config.servers
        elif discipline == 'fastest':
            for server in servers:
                server.latency = tools.test_server_latency(server.remote.addr)
            servers = sorted(server_config.servers,
                             key=lambda server: server.latency)
        elif discipline == 'recent':
            servers = sorted(server_config.servers,
                             key=lambda server: server.recent_order)
        elif discipline == 'rotation':
            servers = sorted(server_config.servers,
                             key=lambda server: server.recent_order,
                             reverse=True)
        else:
            tools.error('Bad server selection discipline: {}'.format(discipline), fatal_error=True)
        # Filter based on port forwarding, or not.
        if server_config.port_forwarding:
            servers = list(filter(lambda server: server.port_forwarding, servers))
        return servers or None

    def get_vpn_data(self, vpn_config_path):
        """Parse OpenVPN configuration file and return select data."""
        class VPNConfigData:
            def __init__(self):
                self.lan_addr = None
                self.def_dev = None
                self.vpn_dev = None
                self.addr = None
                self.port = None
                self.protocol = None
        data = VPNConfigData()
        proc = tools.capture_command('ip', 'route', 'show', always_run=True)
        for line in proc.stdout.split(os.linesep):
            matched = self.iproute_show_regex.search(line)
            if matched:
                data.lan_addr = matched.group(1)
                data.def_dev = matched.group(2)
                break
        else:
            tools.error('Failed to find default device using "ip route show".', fatal_error=True)
        proc = tools.capture_command('sudo', 'cat', self.log_path, always_run=True)
        for line in proc.stdout.split(os.linesep):
            matched = self.vpn_device_regex.search(line)
            if matched:
                data.vpn_dev = matched.group(1)
                break
        else:
            tools.error('Failed to find TUN/TAP device in log.', fatal_error=True)
        with tools.open_input_file(vpn_config_path) as vpn_config_file:
            for line in vpn_config_file:
                matched = self.vpn_config_remote_regex.match(line)
                if matched:
                    data.addr = matched.group(1)
                    data.port = matched.group(2)
                matched = self.vpn_config_protocol_regex.match(line)
                if matched:
                    data.protocol = matched.group(1)
        return data

    def start_firewall(self, config_path,
                       port_forwarding=False,
                       block_lan=False,
                       disable_firewall=False):
        """Start the VPN-tweaked firewall."""
        if not disable_firewall:
            vpn = self.get_vpn_data(config_path)
            tools.info('Resetting the firewall ...')
            firewall.reset()
            tools.info('Starting the firewall ...')
            firewall.start(vpn.def_dev, vpn.vpn_dev, vpn.lan_addr, vpn.port, vpn.protocol)
            if port_forwarding:
                new_string = ' (new)' if self.options.NEW_PORT else ''
                tools.info('Determining{} forwarded port ...'.format(new_string))
                forwarded_port = self.provider.get_forwarded_port(new_port=self.options.NEW_PORT)
                tools.info('Forwarding port {}...'.format(forwarded_port))
                firewall.forward_port(vpn.vpn_dev, forwarded_port)
            if not block_lan:
                tools.info('Enabling LAN address {} on {} ...'.format(vpn.def_dev, vpn.lan_addr))
                firewall.enable_lan(vpn.def_dev, vpn.lan_addr)
            tools.info('Firewall enabled.')


class Install(ProviderSubCommand):
    name = 'install'
    help = 'install PIA/OpenVPN prerequisites and configurations'
    arguments = [
        command.Argument(
            '-r', '--refresh-openvpn-files', dest='REFRESH_OPENVPN_FILES',
            action='store_true', help='force OpenVPN configuration file refresh'
        ),
        command.Argument(
            '-c', '--create-user-config', dest='CREATE_USER_CONFIG', action='store_true',
            help='create new configuration file, even if one exists'
        ),
        command.Argument(
            '-u', '--user-only', dest='USER_ONLY', action='store_true',
            help='only update the user configuration'
        ),
    ]
    def execute(self):
        num_actions = 0
        if not self.options.USER_ONLY:
            num_actions += tools.install_packages(REQUIRED_PACKAGES)
        num_actions += self.provider.install_configuration_files(
            force=self.options.REFRESH_OPENVPN_FILES)
        if not os.path.exists(self.cred_path):
            self.credentials.create()
            num_actions += 1
        if not os.path.exists(self.config_path) or self.options.CREATE_USER_CONFIG:
            self.config.generate()
            num_actions += 1
        if num_actions > 0:
            tools.info('Installation actions performed: {}'.format(num_actions))
        else:
            tools.info('No installation actions were needed.')


class Servers(ProviderSubCommand):
    name = 'servers'
    help = 'list available servers'
    arguments = []
    def execute(self):
        server_rows = []
        server_num = 0
        header = ['Number', 'Name', 'Forwarding', 'Protocols']
        for server in self.openvpn_servers:
            server_num += 1
            protocols = ' '.join(server.protocols)
            server_rows.append([server_num, server.name, server.port_forwarding, protocols])
        tools.display_table(server_rows, header=header, title='Available servers')


class Start(ProviderSubCommand):
    name = 'start'
    help = 'start the PIA/OpenVPN connection'
    arguments = [
        command.Argument(
            '-w', '--wait', dest='WAIT',
            help='do not exit and wait for key to disconnect'
        ),
        command.Argument(
            '-N', '--new-port', dest='NEW_PORT',
            help='assign new forwarded port using new client ID'
        ),
        command.Argument(
            '-s', '--server-config', dest='SERVER_CONFIG', action='store',
            help='server configuration name to use instead of default'
        ),
    ]
    def execute(self):
        # Make sure credentials are available
        self.credentials.get()
        server_config = self.config.get_server(name=self.options.SERVER_CONFIG)
        pid = tools.get_running_pid(pid_path=self.pid_path)
        if pid:
            tools.error('OpenVPN server is already running.', fatal_error=True)
        if self.options.VERBOSE:
            tools.info2(server_config)
        servers = self.select_servers(server_config)
        if not servers:
            tools.error('No matching servers found.', fatal_error=True)
        if self.options.VERBOSE:
            tools.info2(servers)
        tools.delete_file(self.pid_path, self.port_path)
        for server in servers:
            tools.info('Connecting to: {}'.format(server.name))
            cmd_args = ['sudo', 'openvpn']
            if not self.options.WAIT:
                cmd_args.extend(['--daemon', '--log', self.log_path])
            cmd_args.extend(['--config', server.config_path])
            # --auth-user-pass option must follow --config in order to override.
            cmd_args.extend(['--auth-user-pass', self.cred_path])
            if not self.options.WAIT:
                cmd_args.extend(['--writepid', self.pid_path])
            if self.saved_state.data.recent_servers:
                self.saved_state.data.recent_servers.append(server.name)
            else:
                self.saved_state.data.recent_servers = [server.name]
            proc = tools.run_command(*cmd_args)
            if proc.returncode == 0:
                if not self.options.WAIT:
                    if self.options.DRYRUN:
                        pid = -1
                    else:
                        pid = tools.get_running_pid(pid_path=self.pid_path)
                    if pid:
                        tools.info('OpenVPN daemon is running with PID: {}'.format(pid))
                        self.start_firewall(
                            server.config_path,
                            port_forwarding=server.port_forwarding,
                            block_lan=server_config.block_lan,                 #pylint: disable=no-member
                            disable_firewall=server_config.disable_firewall,   #pylint: disable=no-member
                        )
                        break
                    tools.error('OpenVPN does not seem to be running.')
        else:
            if not self.options.WAIT and os.path.exists(self.log_path):
                sys.stderr.write('===== {} (begin) ====={}'.format(
                    self.log_path, os.linesep))
                os.system('sudo cat "{}"'.format(self.log_path))
                sys.stderr.write('===== {} (end) ====={}'.format(
                    self.log_path, os.linesep))
            tools.error('Failed to start PIA OpenVPN server.', fatal_error=True)


class Stop(ProviderSubCommand):
    name = 'stop'
    help = 'stop the PIA/OpenVPN connection'
    arguments = []
    def execute(self):
        pid = tools.get_running_pid(pid_path=self.pid_path)
        if not pid:
            tools.error('OpenVPN server does not appear to be running.', fatal_error=True)
        tools.info('Killing OpenVPN server PID: {}'.format(pid))
        tools.run_command('sudo', 'kill', pid)
        tools.delete_file(self.pid_path, self.port_path)


class Status(ProviderSubCommand):
    name = 'status'
    help = 'display connection status'
    arguments = []
    def execute(self):
        pid = tools.get_running_pid(pid_path=self.pid_path)
        def _path(path):
            path2 = tools.shorten_path(path)
            if not os.path.exists(path):
                return tools.DisplayItem(path2, tools.DisplayItem(' (missing)', attributes='red'))
            return path2
        tools.display_table([
            ['Server status', 'running' if pid else 'not running'],
            ['Process ID', str(pid) if pid is not None else '-'],
            ['Base directory', _path(self.base_dir)],
            ['Configuration directory', _path(self.config_dir)],
            ['Downloads directory', _path(self.download_dir)],
            ['State directory', _path(self.state_dir)],
            ['Configuration file', _path(self.config_path)],
            ['Credentials file', _path(self.cred_path)],
            ['Log file', _path(self.log_path)],
            ['State file', _path(self.state_path)],
            ['Process PID file', _path(self.pid_path)],
            ['Forwarded port file', _path(self.port_path)],
        ] + [[label, _path(path)] for label, path in self.provider.iterate_status_paths()],
        header=['Description', 'Data'])


class Credentials(ProviderSubCommand):
    name = 'credentials'
    help = 'save PIA/OpenVPN user credentials'
    arguments = [
        command.Argument('-f', '--force', dest='FORCE', action='store_true',
                 help='force by overwriting existing file as needed'),
    ]
    def execute(self):
        if os.path.exists(self.cred_path) and not self.options.FORCE:
            tools.info('Credentials file exists:', [self.cred_path])
            return
        self.credentials.create()


class Log(ProviderSubCommand):
    name = 'log'
    help = 'follow PIA/OpenVPN log output'
    def execute(self):
        pid = tools.get_running_pid(pid_path=self.pid_path)
        if pid:
            os.execvp('sudo', ['sudo', 'tail', '-f', self.log_path])
        tools.error('OpenVPN does not seem to be running.')


if __name__ == '__main__':
    try:
        command.main(COMMAND_DESCRIPTION)
    except KeyboardInterrupt:
        sys.exit(2)
